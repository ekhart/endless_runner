-- todo: 
-- DRY keys "road4"

go.property("road4", 200)
go.property("road3", 440)
go.property("road2", 640)
go.property("road1", 880)

go.property("spawn_density", 460)
go.property("spawn_probability", 0.2)
go.property("enemy_spawn_y", 2000)

go.property("speed", 6)
go.property("speed_up_size", 1)
go.property("speed_up_every_second", 1.0)

local points = 0

local function get(property)
	return go.get("#", property)
end

local enemy_factories = { "#enemy_factory", "#enemy_slow_factory" }

function init(self)
	self.gridw = 0
	self.enemies = {}

	time_from_start = 0.0
	speed_up_accumulator = 0.0
	spawn_density = get("spawn_density")
	spawn_probability = get("spawn_probability")
	speed_up_size = get("speed_up_size")
	speed_up_every_second = get("speed_up_every_second")
	
	speed = get("speed")
	roads = { get("road4"), get("road3"), get("road2"), get("road1") }
	msg.post("player#script", "set_roads", { roads = roads })
	enemy_spawn_y = get("enemy_spawn_y")

	print("controller.init")
	msg.post(".", "acquire_input_focus")
end

function final(self)
	print("controller.final")
	msg.post(".", "release_input_focus")
end


local function print_time(dt)
	local position = vmath.vector3(100, 100, 0)
	local text = string.format( "%.2f", time_from_start)
	local message = { text = text, position = position }
	-- print("text = " .. text)
	msg.post("@render:", "draw_text", message)
end

local function post_gui(message_id, message)
	msg.post("level:/hud#gui", message_id, message)
end

local function update_time(self, dt)
	time_from_start = time_from_start + dt
	speed_up_accumulator = speed_up_accumulator + dt
	
	-- print_time(dt)
	-- print("controller.set_time")
	post_gui("set_time", { time = time_from_start })

	if speed_up_accumulator > speed_up_every_second then
		speed_up_accumulator = 0
		
		msg.post("ground/controller#script", "add_speed", { speed = speed_up_size })

		for i, enemy in ipairs(self.enemies) do
			msg.post(enemy, "add_speed", { speed = speed_up_size })
		end
	end
end

local function spawn_enemy(self, dt)
	self.gridw = self.gridw + self.speed

	if self.gridw >= spawn_density then
		self.gridw = 0
		
		if math.random() > spawn_probability then
			local x = roads[math.random(#roads)]
			local is_left_road = x == get("road4") or x == get("road3")
			local enemy_factory = enemy_factories[is_left_road and 2 or 1]
			local pos = vmath.vector3(x, enemy_spawn_y, 1)
			local enemy = factory.create(enemy_factory, pos, nil, {}, 0.6)
			
			-- print("construct")
			-- pprint(enemy)
			msg.post(enemy, "construct", { x = x, is_left_road = is_left_road })
			table.insert(self.enemies, enemy)
		end
	end
end

function update(self, dt)
	update_time(self, dt)
	spawn_enemy(self, dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("add_point") then
		points = points + 1
		post_gui("set_points", { points = points })
	end
end